"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeEosjs = exports.deserializeAbieos = void 0;
const worker_threads_1 = require("worker_threads");
const text_encoding_1 = require("text-encoding");
const nodeAbieos = __importStar(require("@eosrio/node-abieos"));
const eosjs_1 = require("eosjs");
// NOTE: you need use function instead of arrow here in the deserializer, see Nodejs worker_threads documentation
function deserializeAbieos({ code, data, type }) {
    //  console.log({ code, data, type })
    return data === 'string' ? nodeAbieos.hex_to_json(code, type, data) : nodeAbieos.bin_to_json(code, type, Buffer.from(data));
}
exports.deserializeAbieos = deserializeAbieos;
function deserializeEosjs({ type, data, types }) {
    const dataArray = typeof data === 'string' ? Uint8Array.from(Buffer.from(data, 'hex')) : data;
    const buffer = new eosjs_1.Serialize.SerialBuffer({ textEncoder: new text_encoding_1.TextEncoder(), textDecoder: new text_encoding_1.TextDecoder(), array: dataArray });
    const result = eosjs_1.Serialize.getType(types, type).deserialize(buffer, new eosjs_1.Serialize.SerializerState({ bytesAsUint8Array: true }));
    if (buffer.readPos !== data.length)
        throw new Error(`Deserialization error: ${type}`);
    return result;
}
exports.deserializeEosjs = deserializeEosjs;
function processDeserializationRequest({ code, data, type, table, action }) {
    var _a, _b;
    if (!data)
        return worker_threads_1.parentPort.postMessage({ success: false, message: 'Empty data received on deserialize worker' });
    const args = worker_threads_1.workerData;
    // get the correct abi and types for table deserialization
    const deserializationAbi = args.abis.get(code);
    if (!deserializationAbi) {
        return worker_threads_1.parentPort.postMessage({ success: false, message: `Deserialization ABI not found for contract ${code}` });
    }
    let deserializationType = type;
    if (table) {
        deserializationType = (_a = deserializationAbi.tables.find(({ name }) => name === table)) === null || _a === void 0 ? void 0 : _a.type;
    }
    else if (action) {
        deserializationType = (_b = deserializationAbi.actions.find(({ name }) => name === action)) === null || _b === void 0 ? void 0 : _b.type;
    }
    if (!deserializationType)
        return worker_threads_1.parentPort.postMessage({ success: false, message: 'Deserialization type not found' });
    let result;
    if (args.ds_experimental) {
        result = deserializeAbieos({ code, type: deserializationType, data });
    }
    else {
        const deserializationTypes = eosjs_1.Serialize.getTypesFromAbi(eosjs_1.Serialize.createInitialTypes(), deserializationAbi);
        if (!deserializationTypes)
            return worker_threads_1.parentPort.postMessage({ success: false, message: 'Deserialization types not found' });
        result = deserializeEosjs({ type: deserializationType, data, types: deserializationTypes });
    }
    return result;
}
// deserialization workers
if (worker_threads_1.parentPort) {
    // You can do any heavy stuff here, in a synchronous way without blocking the "main thread"
    worker_threads_1.parentPort.on('message', (params) => {
        try {
            let result;
            if (Array.isArray(params)) {
                result = [];
                params.forEach((param) => result.push(processDeserializationRequest(param)));
            }
            else {
                result = processDeserializationRequest(params);
            }
            return worker_threads_1.parentPort.postMessage({ success: true, data: result });
        }
        catch (e) {
            console.log('error', e);
            return worker_threads_1.parentPort.postMessage({ success: false, message: String(e) });
        }
    });
}
//# sourceMappingURL=deserializer.js.map